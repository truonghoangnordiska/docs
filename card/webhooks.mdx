---
title: "Webhooks"
description: "Complete guide to webhook implementation for card onboarding events"
---

Webhooks provide real-time notifications about changes in the card onboarding process. Your system will receive HTTP POST requests whenever significant events occur.

## Configuration

<Warning>
Webhook endpoints must be configured by your Nordiska integration contact before going live.
</Warning>

### Requirements

Your webhook endpoint must:
- Accept HTTP POST requests
- Respond with HTTP 200 status for successful processing
- Process requests within 30 seconds
- Be accessible over HTTPS
- Verify webhook signatures for security

### Retry Policy

If your endpoint doesn't respond with HTTP 200:
- **First retry**: After 1 minute
- **Second retry**: After 5 minutes  
- **Third retry**: After 30 minutes
- **Final retry**: After 2 hours

After 4 failed attempts, webhook delivery stops and manual intervention may be required.

## Webhook Events

Your system should handle these webhook events:

### SIGNING_SESSION_CREATED

Triggered when a credit card application is approved and ready for document signing.

```json
{
  "eventType": "SIGNING_SESSION_CREATED",
  "onboardingId": "7a0d9433-4f64-4f93-919c-5ab7d81eea55",
  "signingSessionId": "1fa6ef79-16e7-4665-ae78-c885e65e372b",
  "signingUrl": "https://sign.dev.nordiska.com/?sessionId=1fa6ef79-16e7-4665-ae78-c885e65e372b",
  "timestamp": "2024-01-15T10:35:00Z"
}
```

**Required Actions**:
1. Store the signing URL for customer redirect
2. Update onboarding status to `AWAITING_SIGNING`
3. Redirect customer to complete document signing
4. Set up abandonment tracking for follow-up

**Customer Journey**:
- Customer receives notification to complete signing
- Redirect to Nordiska's signing service
- Customer reviews and signs credit agreement
- Automatic redirect back to your platform

### SIGNING_SESSION_COMPLETED

Triggered when a customer successfully completes document signing.

```json
{
  "eventType": "SIGNING_SESSION_COMPLETED",
  "onboardingId": "7a0d9433-4f64-4f93-919c-5ab7d81eea55",
  "signingSessionId": "1fa6ef79-16e7-4665-ae78-c885e65e372b",
  "timestamp": "2024-01-15T10:45:00Z"
}
```

**Required Actions**:
1. Update onboarding status to `AWAITING_CARD_CREATION`
2. Initiate card creation process in Enfuce
3. Send confirmation notification to customer
4. Begin account setup procedures

**Next Steps**:
- Create customer record in Enfuce
- Set up credit account with approved limit
- Order physical/virtual card
- Configure account access

### ONBOARDING_COMPLETED

Triggered when the entire onboarding process finishes successfully.

```json
{
  "eventType": "ONBOARDING_COMPLETED",
  "onboardingId": "7a0d9433-4f64-4f93-919c-5ab7d81eea55",
  "engagementId": "8b9fd836-9d01-4c91-b0e0-17dfc26944e9",
  "timestamp": "2024-01-15T11:00:00Z"
}
```

**Required Actions**:
1. Update onboarding status to `COMPLETED`
2. Activate customer's credit account
3. Send welcome communications
4. Enable card management features
5. Store engagement ID for future reference

**Customer Benefits**:
- Immediate access to virtual card
- Physical card shipping notification
- Account dashboard access
- Credit facility activation

### ONBOARDING_REJECTED

Triggered when a credit card application is declined during assessment.

```json
{
  "eventType": "ONBOARDING_REJECTED",
  "onboardingId": "7a0d9433-4f64-4f93-919c-5ab7d81eea55",
  "rejectReason": "CREDIT_SCORING_DENIAL",
  "timestamp": "2024-01-15T10:33:00Z"
}
```

**Rejection Reasons**:

<Tabs>
  <Tab title="KYC_DENIAL">
    **Cause**: Failed identity verification or sanctions screening
    
    **Customer Action**:
    - Contact customer support for manual review
    - Provide additional documentation if requested
    - May require in-person verification
    
    **Partner Action**:
    - Explain rejection reason clearly
    - Provide support contact information
    - Log case for compliance tracking
  </Tab>
  
  <Tab title="CREDIT_SCORING_DENIAL">
    **Cause**: Insufficient creditworthiness based on bureau data
    
    **Customer Action**:
    - Can reapply after 3 months
    - Improve credit profile in the meantime
    - Consider alternative products
    
    **Partner Action**:
    - Communicate waiting period
    - Suggest credit improvement tips
    - Offer alternative financial products
  </Tab>
</Tabs>

**Required Actions**:
1. Update onboarding status to `REJECTED`
2. Send appropriate rejection communication
3. Provide clear next steps to customer
4. Log rejection for analytics and compliance

### ONBOARDING_FAILED

Triggered when a technical error occurs during the onboarding process.

```json
{
  "eventType": "ONBOARDING_FAILED",
  "onboardingId": "7a0d9433-4f64-4f93-919c-5ab7d81eea55",
  "failureCode": "ADDRESS_MISMATCH",
  "timestamp": "2024-01-15T10:31:00Z"
}
```

**Failure Codes**:

| Code | Description | Resolution |
|------|-------------|------------|
| `INTERNAL_ERROR` | System error requiring investigation | Contact support, retry after resolution |
| `ADDRESS_MISMATCH` | Address doesn't match official records | Update application with correct address |
| `NAME_MISMATCH` | Name doesn't match official records | Verify spelling, provide correct legal name |
| `ID_VERIFICATION_FAILED` | Identity verification failed | Provide additional documentation |
| `TIMEOUT` | Process timeout occurred | Retry application |

**Required Actions**:
1. Update onboarding status to `FAILED`
2. Log error details for investigation
3. Notify customer if appropriate (not for internal errors)
4. Provide resolution path when available

## Webhook Security

All webhooks include security headers to verify authenticity and prevent attacks.

### Headers

```http
X-Nordiska-Signature: sha256=a1b2c3d4e5f6...
X-Nordiska-Timestamp: 1642234800
X-Nordiska-Idempotency-Key: uuid-v4-here
Content-Type: application/json
```

### Signature Verification

Verify the HMAC signature to ensure webhook authenticity:

<CodeGroup>

```javascript Node.js
const crypto = require('crypto');

function verifyWebhook(payload, signature, secret, timestamp) {
  // Check timestamp (reject if older than 5 minutes)
  const currentTime = Math.floor(Date.now() / 1000);
  if (Math.abs(currentTime - timestamp) > 300) {
    throw new Error('Webhook timestamp too old');
  }
  
  // Verify signature
  const signedPayload = `${timestamp}.${payload}`;
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  const receivedSignature = signature.replace('sha256=', '');
  
  return crypto.timingSafeEqual(
    Buffer.from(expectedSignature),
    Buffer.from(receivedSignature)
  );
}

// Usage in Express.js
app.post('/webhooks/nordiska', express.raw({type: 'application/json'}), (req, res) => {
  const signature = req.headers['x-nordiska-signature'];
  const timestamp = req.headers['x-nordiska-timestamp'];
  const payload = req.body.toString();
  
  try {
    if (!verifyWebhook(payload, signature, process.env.WEBHOOK_SECRET, timestamp)) {
      return res.status(401).send('Invalid signature');
    }
    
    const event = JSON.parse(payload);
    // Process webhook event
    handleWebhookEvent(event);
    
    res.status(200).send('OK');
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(400).send('Error processing webhook');
  }
});
```

```python Python
import hmac
import hashlib
import time
import json

def verify_webhook(payload: str, signature: str, secret: str, timestamp: int) -> bool:
    # Check timestamp (reject if older than 5 minutes)
    current_time = int(time.time())
    if abs(current_time - timestamp) > 300:
        raise ValueError("Webhook timestamp too old")
    
    # Verify signature
    signed_payload = f"{timestamp}.{payload}"
    expected_signature = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    received_signature = signature.replace('sha256=', '')
    
    return hmac.compare_digest(expected_signature, received_signature)

# Usage in Flask
from flask import Flask, request

@app.route('/webhooks/nordiska', methods=['POST'])
def handle_webhook():
    signature = request.headers.get('X-Nordiska-Signature')
    timestamp = int(request.headers.get('X-Nordiska-Timestamp'))
    payload = request.get_data(as_text=True)
    
    try:
        if not verify_webhook(payload, signature, WEBHOOK_SECRET, timestamp):
            return 'Invalid signature', 401
        
        event = json.loads(payload)
        # Process webhook event
        handle_webhook_event(event)
        
        return 'OK', 200
    except Exception as error:
        print(f'Webhook error: {error}')
        return 'Error processing webhook', 400
```

```java Java
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.time.Instant;

public class WebhookVerifier {
    
    public static boolean verifyWebhook(String payload, String signature, 
                                       String secret, long timestamp) {
        // Check timestamp (reject if older than 5 minutes)
        long currentTime = Instant.now().getEpochSecond();
        if (Math.abs(currentTime - timestamp) > 300) {
            throw new IllegalArgumentException("Webhook timestamp too old");
        }
        
        try {
            // Verify signature
            String signedPayload = timestamp + "." + payload;
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(), "HmacSHA256");
            mac.init(secretKey);
            
            byte[] hash = mac.doFinal(signedPayload.getBytes());
            String expectedSignature = bytesToHex(hash);
            String receivedSignature = signature.replace("sha256=", "");
            
            return MessageDigest.isEqual(
                expectedSignature.getBytes(), 
                receivedSignature.getBytes()
            );
        } catch (Exception e) {
            throw new RuntimeException("Error verifying webhook signature", e);
        }
    }
    
    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
```

</CodeGroup>

### Idempotency

Use the `X-Nordiska-Idempotency-Key` header to prevent duplicate processing:

```javascript
const processedWebhooks = new Set();

function handleWebhook(event, idempotencyKey) {
  if (processedWebhooks.has(idempotencyKey)) {
    console.log('Duplicate webhook ignored');
    return;
  }
  
  // Process the webhook
  processWebhookEvent(event);
  
  // Mark as processed
  processedWebhooks.add(idempotencyKey);
}
```

## Testing Webhooks

### Development Environment

For testing webhooks during development:

1. **Use ngrok or similar service** to expose your local server
   ```bash
   ngrok http 3000
   ```

2. **Configure test webhook URL** with your Nordiska contact
   ```
   https://abc123.ngrok.io/webhooks/nordiska
   ```

3. **Test with special names** in applications to trigger specific events

### Testing Tools

<Tabs>
  <Tab title="Webhook.site">
    - Visit [webhook.site](https://webhook.site)
    - Get a unique URL for testing
    - View incoming webhook payloads
    - Test signature verification
  </Tab>
  
  <Tab title="Postman">
    - Create mock webhook endpoints
    - Test signature verification logic
    - Simulate different event types
    - Test error handling
  </Tab>
  
  <Tab title="Custom Test Server">
    ```javascript
    const express = require('express');
    const app = express();
    
    app.use(express.raw({type: 'application/json'}));
    
    app.post('/webhooks/test', (req, res) => {
      console.log('Headers:', req.headers);
      console.log('Body:', req.body.toString());
      res.status(200).send('OK');
    });
    
    app.listen(3000, () => {
      console.log('Test webhook server running on port 3000');
    });
    ```
  </Tab>
</Tabs>

## Best Practices

### Error Handling

- **Always respond with HTTP 200** for successfully processed webhooks
- **Log all webhook events** for debugging and audit trails
- **Implement retry logic** for transient failures in your processing
- **Use dead letter queues** for failed webhook processing

### Performance

- **Process webhooks asynchronously** to avoid timeout issues
- **Keep webhook endpoints lightweight** - queue heavy processing
- **Scale webhook endpoints** to handle traffic spikes
- **Monitor webhook processing times**

### Security

- **Always verify signatures** before processing webhook data
- **Check timestamps** to prevent replay attacks
- **Use HTTPS** for all webhook endpoints
- **Rotate webhook secrets** periodically
- **Log suspicious activity** (invalid signatures, old timestamps)

### Monitoring

Set up alerts for:
- Failed webhook deliveries
- High webhook processing times
- Invalid signature attempts
- Missing webhook events
- Webhook endpoint downtime

---

Need help with webhook implementation? Contact your Nordiska integration specialist for technical support. 